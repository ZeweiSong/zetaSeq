#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Created on Thu May 19 17:33:42 2022

Dereplicate a group of contigs

dereco prep -i /path/to/contigs.fa.gz -o /path/to/out/folder/ -c 1000000
dereco cacl -i /path/to/out/folder -t 4

He who loves to comment his code is unlikely to have bad luck.
@author: Song, Zewei
@contact: songzewei@genomics.cn
"""

import argparse
import sys
import os
import json
import shutil
from zetaSeq import io as seqIO


def print_help():
    print('')
    print('DereCo: dereplicate a group of contigs')
    print('--------------------')
    print('Choose an option:')
    print('create     CREATE a working folder from a fromile or files in a directory.')
    print('calculate  CALCULATE similarity and remove redundant sequences.')
    print('update     UPDATE a working directory with new files in the target path.')
    print('status     Print out the STATUS of a working directory.')
    print('--------------------')
    print('Song, Zewei')
    print('songzewei@genomics.cn')
    print('')


def create(args_input, args_output, args_cutoff, args_minlen):
    print('Dereco: dereplicate a group of contigs')
    folder = False
    fagz = []
    sn = ''
    if os.path.isfile(args_input):  # Input is a file
        print('Origin file: {0}'.format(args_input))
        if args_input.endswith('.fa') or args_input.endswith('.fa.gz'):
            pass
        else:
            print('[ERROR] The input file has to be .fa or .fa.gz')
            sys.exit()
        target_file = args_input
    elif os.path.isdir(args_input):  # Input is a folder
        folder = True
        if not args_input.endswith('/'): args_input += '/'
        print('Origin directory: {0}'.format(args_input))
        # Search in the target folder for all .fa.gz files, .fa will be ignored
        count_fa = 0
        for item in os.listdir(args_input):
            if item.endswith('.fa.gz'):
                fagz.append(args_input + item)
            elif item.endswith('.fa'):
                count_fa += 1
        if count_fa > 0:
            print('Found {0} .fa files in {1}, but will not add them to the working directory'.format(count_fa,
                                                                                                      args_input))
        if len(fagz) == 0:
            print('Found 0 .fa.gz files')
            print('[DereCo] EXIT')
            sys.exit()

    # Check if the output folder exist
    if not args_output.endswith('/'): args_output += '/'
    if os.path.isdir(args_output):
        print('[ERROR] The output folder {0} already exist, please check it.'.format(args_output))
        sys.exit()
    else:
        os.mkdir(args_output)
        print('Working folder generated at: {0}'.format(args_output))

    # Write an option file
    options = {'cutoff': args_cutoff, 'minlen': args_minlen,
               'target': args_input, 'wd': args_output,
               'folder': folder, 'final': '', 'finished': False,
               'threads': 1, 'added': []}
    if folder:
        options['added'] = fagz

    # Rename the sequence names to avoid duplicated label
    if folder:  # Target is a folder, will concat all its .fa.gz files first
        cmd = ['cat']
        cmd += [' '.join(fagz)]
        cmd += ['> ' + args_output + '_tmp.cat.fa.gz']
        target_file = args_output + '_tmp.cat.fa.gz'
        cmd = ' '.join(cmd)
        if len(fagz) >= 10:
            print('[SHELL ] cat ' + ' '.join(fagz[:8]) + ' ... ' + fagz[10] + ' > ' + args_output + '_tmp.cat.fa.gz') 
        else:
            print('[SHELL] ' + cmd)
        os.system(cmd)
    else:
        target_file = args_input
    cmd = ['seqtk seq -L ' + str(args_minlen)]
    cmd += ['-C'] # -C is requied to remove all comments
    cmd += [target_file]
    cmd += ['|']
    cmd += ['seqtk rename -']
    cmd += ['contigs_']
    cmd += ['>']
    cmd += [args_output + '_tmp.cat.renamed.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)
    if folder:
        os.system('rm ' + args_output + '_tmp.cat.fa.gz')  # remove the temp cat file

    # Write large and small sequences to the working folder
    print('Length cutoff: {0}'.format(args_cutoff))
    file_large = args_output + 'contigs.large.fa'
    file_small = args_output + 'contigs.small.fa'
    options['large_file'] = file_large
    options['small_file'] = file_small

    cmd = ['vsearch --fastx_filter']
    cmd += [args_output + '_tmp.cat.renamed.fa']
    cmd += ['--fastq_minlen ' + str(args_cutoff)]
    cmd += ['--fastaout ' + file_large]
    cmd += ['--fastaout_discarded ' + file_small]
    cmd += ['--fasta_width 0']
    cmd += ['--quiet']
    cmd = ' '.join(cmd)
    print('[VSEARCH] ' + cmd)
    os.system(cmd)
    os.remove(args_output + '_tmp.cat.renamed.fa')

    if os.stat(file_large).st_size == 0:  # Check if the large file is empty
        print('[DereCo] The large file is empty, you may want to lower the cutoff.')
        shutil.rmtree(args_output)
        print('[DereCo] {0} removed'.format(args_output))
        print('[DereCo] EXIT')
        sys.exit()
    else:
        with open(args_output + 'FLOW', 'w') as f:
            f.write('{0}\t{1}\n'.format(file_large, file_large))
            f.write('{0}\t{1}\n'.format(file_small, file_large))
            f.write('{0}\t{1}\n'.format(file_small, file_small))

        # Save the options.json file
    with open(args_output + 'options.json', 'w') as f:
        json.dump(options, f)

    print('[DereCo] Generated the LARGE file: {0}'.format(file_large))
    print('[DereCo] Generated the SMALL file: {0}'.format(file_small))
    print('[DereCo] Generated options.jaon')
    print('[DereCo] Generated FLOW')
    print('[DereCo] Next run: dereco calculate -i {0} -t [threads]'.format(args_output))

    return None


# retuen a list of query names to be removed from alignments
def derep_paf(input_paf, offset):
    removal = []
    with open(input_paf, 'r') as f:
        for line in f:
            line = line.strip('\n').split('\t')
            if line[0] != line[5] and int(line[1]) < int(line[6]):  # alignment is short --> long
                ident = float(int(line[10]) / int(line[9]))  # This is the identity (similarity) of the alignment
                match = float(int(line[10]) / (int(line[1]) - offset))  # This is the percent of length matched on query
                if ident > 0.99 and match > 0.97:
                    removal.append(line[0])
        removal = set(removal)
    return removal

# Dereplicate a query file against the ref file
def dereplicate(query, ref, threads, offset):
    # minimap2 asm5 ref query
    cmd = ['minimap2']
    cmd += ['-x asm5']
    cmd += ['-t ' + str(threads)]
    cmd += [ref]
    cmd += [query]
    cmd += ['-o ' + '_tmp.paf']
    cmd += ['2> /dev/null']
    cmd = ' '.join(cmd)
    print('[MINIMAP2] ' + cmd)
    os.system(cmd)

    # dereplicate query against ref
    removal = derep_paf('_tmp.paf', offset)
    keep = [i[0] for i in seqIO.sequence(query) if i[0] not in removal]
    print('[DereCo] Removing {0} sequences ...'.format(len(removal)))
    with open('_kplist', 'w') as f:
        f.write('{0}\n'.format('\n'.join(keep)))
    cmd = ['seqtk subseq']
    cmd += [query]
    cmd += ['_kplist']
    cmd += ['> ' + '_query.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)

    # replace old query with new query
    os.remove(query)
    shutil.move('_query.fa', query)
    os.remove('_kplist')
    os.remove('_tmp.paf')
    print('[DereCo] {0} is dereplicated'.format(query))

    return None

def get_size_count(input_seqs):
    size = 0
    count = 0
    for item in seqIO.sequence(input_seqs):
        count += 1
        size += len(item[1])
    return size, count


def calculate(args_input, args_threads, args_offset):
    if not args_input.endswith('/'): args_input += '/'
    if not os.path.isfile(args_input + 'options.json'):
        print('[ERROR] Did not find options.json, use "dereco create" to set up the working directory.')
        sys.exit()
    elif not os.path.isfile(args_input + 'FLOW'):
        print('[ERROR] Did not find FLOW, use "dereco create" to set up the working directory.')
    else:
        with open(args_input + 'options.json', 'r') as f:
            options = json.load(f)
            if options['finished']:
                print('[DeroCo] This directory is marked as FINISHED')
                sys.exit()
            else:
                flow = []
                with open(args_input + 'FLOW', 'r') as f:
                    for line in f:
                        line = line.strip('\n').split('\t')
                        flow.append(tuple(line))

    print('Cutoff: {0}'.format(options['cutoff']))
    print('Minimum length: {0}'.format(options['minlen']))
   
    sum0 = [0,0]
    c0 = [0, 0]
    sum0[0], c0[0] = get_size_count(options['large_file'])
    sum0[1], c0[1] = get_size_count(options['small_file']) 
    print('[DereCo] FLOW started:')
    for item in flow:
        query = item[0]
        ref = item[1]
        if not os.path.isfile(query):
            print('[ERROR] {0} is missing'.format(query))
            print('[DereCo] EXIT')
            sys.exit()
        elif not os.path.isfile(ref):
            print('[ERROR] {0} is missing'.format(ref))
            print('[DereCo] EXIT')
            sys.exit()
        print('[DereCo] FLOW: {0} -> {1}'.format(query, ref))
        # sum_ref, count_ref = get_size_count(ref)
        sum_query, count_query = get_size_count(query)
        dereplicate(query, ref, args_threads, args_offset)
        sum1, c1 = get_size_count(query)
        print('[DereCo] Dereplicated {4}: {0:,} -> {1:,} (bps) / {2:,} -> {3:,} (count)'.format(sum_query, sum1, count_query, c1, query))

    # concat all and rename with prefix nrc_ aka Non-redundant contigs
    cmd = ['cat']
    cmd += [options['large_file']]
    cmd += [options['small_file']]
    cmd += ['| seqtk rename - nrc_ > ' + args_input + 'dereco_final.fa']
    cmd = ' '.join(cmd)
    print('[SHELL] ' + cmd)
    os.system(cmd)

    options['final'] = args_input + 'dereco_final.fa'
    options['finished'] = True
    with open(args_input + 'options.json', 'w') as f:
        json.dump(options, f)

    if os.path.isfile(args_input + 'dereco_final.fa'):
        os.system('touch ' + args_input + 'FINISHED')
    
    sum1, c1 = get_size_count(args_input + 'dereco_final.fa')
    print('\n\t---Report---')
    print('Compression rate: {0:.2f}'.format(sum(sum0) / (sum1)))
    print('Origin size / Derep size: {0:,} / {1:,}'.format(sum(sum0), sum1))
    if options['folder']:
        print('To update: dereco update -i {0} -t [threads]'.format(options['wd']))


def update(args_input):
    # Check options.json
    if os.path.isfile(args_input + 'options.json'):
        with open(args_input + 'options.json', 'r') as f:
            options = json.load(f)
    contigs_add = []
    if not options['folder']:  # Target is not a folder
        print('[ERROR] Target is a file not a directory.')
        print('[DereCo] EXIT')
    elif not options['finished']:  # Input directory is NOT finished
        print('[ERROR] Input directory is not finished.')
        print('[DereCo] run: dereco calculate -i {0} -t [threads]'.format(options['wd']))
    else:
        print('[DereCo] {0} is a FINISHED working directory'.format(options['wd']))
        print('[DereCo] Update contigs (.fa.gz) in {0}'.format(options['target']))
        print('[DereCo] Finished contigs: {0}'.format(len(options['added'])))
        contigs_finished = set([i.split('/')[-1] for i in options['added']])
        for item in os.listdir(options['target']):
            if item.endswith('.fa.gz'):
                if item not in contigs_finished:
                    contigs_add.append(options['target'] + item)
                    print('[DereCo] Add new contig: {0}'.format(item))
        if len(contigs_add) > 0:
            print('[DereCo] Added {0} new contig(s)'.format(len(contigs_add)))
            options['added'] += contigs_add
        else:
            print('[DereCo] No new contigs found in {0}'.format(options['target']))
            print('[DereCo] EXIT')
            sys.exit()

    # concat new contigs as new small file
    options['small_file'] = options['wd'] + 'contigs.small.fa'
    cmd = ['cat']
    cmd += [' '.join(contigs_add)]
    cmd += ['| seqtk seq -L ' + str(options['minlen']) + ' -C | seqtk rename - added_ > ' + options['small_file']] # need to use seqtk seq -C to remove comments in labels
    cmd = ' '.join(cmd)
    print('[SHELL] ' + cmd)
    os.system(cmd)

    # Set large_file = final
    options['large_file'] = options['wd'] + 'contigs.large.fa'
    cmd = ['mv']
    cmd += [options['final']]
    cmd += [options['large_file']]
    cmd = ' '.join(cmd)
    print('[SHELL] ' + cmd)
    shutil.move(options['final'], options['large_file'])
    options['final'] = ''
   
    # Write a new FLOW to update
    with open(args_input + 'FLOW', 'w') as f:
        f.write('{0}\t{1}\n'.format(options['small_file'], options['small_file']))
        f.write('{0}\t{1}\n'.format(options['small_file'], options['large_file']))
        f.write('{0}\t{1}\n'.format(options['large_file'], options['small_file']))

    # Turn off finished flag
    options['finished'] = False
    with open(args_input + 'options.json', 'w') as f:
        json.dump(options, f)
    if os.path.isfile(options['wd'] + 'FINISHED'):
        os.remove(options['wd'] + 'FINISHED')

    # Print calculate command
    print('[DereCo] Working directory set up ready')
    print('[DereCo] WD = {0}'.format(options['wd']))
    print('[DereCo] Large file = {0}'.format(options['large_file']))
    print('[DereCo] Small file = {0}'.format(options['small_file']))
    print('[DereCo] New FLOW is ready')
    print('[DereCo] NEXT run: dereco calculate -i {0} -t [threads]'.format(options['wd']))


def status(args_input):
    print('[DereCo] Checking {0}'.format(args_input))
    if not args_input.endswith('/'): args_input += '/'
    if not os.path.isdir(args_input):
        print('[ERROR] {0} not exist')
        print('[DereCo] EXIT')
        sys.exit()
    else:
        if not os.path.isfile(args_input + 'options.json'):
            print('[ERROR] options.json not exist, {0} is not a working directory'.format(args_input))
            print('[DereCo] EXIT')
            sys.exit()
        else:
            with open(args_input + 'options.json', 'r') as f:
                options = json.load(f)
            print('[DereCo] Loading options.json')
    if options['finished']:
        print('[DereCo] Project is FINISHED')
        print('[DereCo] Project path: {0}'.format(options['wd']))
        print('[DereCo] Non-redundant contigs set in {0}'.format(options['final']))
        print('[DereCo] Compressed from {0} files'.format(len(options['added'])))
        print('[DereCo] Cutoff = {0:,}'.format(options['cutoff']))
        print('[DereCo] Minimum length = {0:,}'.format(options['minlen']))
        print('[DereCo] Path to update: {0}'.format(options['target']))
    else:
        print('[DereCo] Project is NOT finished')
        print('[DereCo] Project path: {0}'.format(options['wd']))
        print('[DereCo] Cutoff = {0:,}'.format(options['cutoff']))
        print('[DereCo] Minimum length = {0:,}'.format(options['minlen']))
        print('[DereCo] Source of contigs: {0}'.format(options['target']))
        print('[DereCo] Added {0} files'.format(len(options['added'])))
    with open(args_input + 'FLOW', 'r') as f:
        print('[DereCo] FLOW')
        for line in f:
            line = line.strip('\n').split('\t')
            print('[DereCo] FLOW: {0} -> {1}'.format(line[0], line[1]))


if len(sys.argv[:]) == 1:
    option = ''
else:
    option = sys.argv[1]
if option == 'create':
    print('CREATE a working folder from a file or files in a directory.')
    parser = argparse.ArgumentParser(prog='dereco create')
    parser.add_argument('-i', '--input', help='Path to the original contigs group file.')
    parser.add_argument('-o', '--output', help='Path to the output folder.')
    parser.add_argument('-c', '--cutoff', type=int, default=1000000, help='Length cutff to divide the input.')
    parser.add_argument('-m', '--minlen', type=int, default=2000, help='Minimum length to keep a sequence.')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        create(args.input, args.output, args.cutoff, args.minlen)
elif option in ('calculate', 'calc'):
    print('CALCULATE similarity and dereplicate')
    parser = argparse.ArgumentParser(prog='dereco calculate')
    parser.add_argument('-i', '--input', help='Path to the prep output folder.')
    parser.add_argument('-f', '--offset', default=0, type=int, help='Offset for the match length')
    parser.add_argument('-t', '--threads', type=int, default=2, help='Numer of threads')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        calculate(args.input, args.threads, args.offset)
elif option == 'update':
    print('UPDATE a working directory for new contigs in the target path')
    parser = argparse.ArgumentParser(prog='dereco update')
    parser.add_argument('-i', '--input', help='Path to the stat output folder.')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        update(args.input)
elif option in ('status', 'stat'):
    print('STATUS of a working directory')
    parser = argparse.ArgumentParser(prog='dereco status')
    parser.add_argument('-i', '--input', help='Path to the working directory.')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        status(args.input)
else:
    print_help()
