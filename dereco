#!/usr/bin/env python
# -*- coding: utf-8 -*-

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Thu May 19 17:33:42 2022

Dereplicate a group of contigs

dereco prep -i /path/to/contigs.fa.gz -o /path/to/out/folder/ -c 1000000
dereco cacl -i /path/to/out/folder -t 4

He who loves to comment his code is unlikely to have bad luck.
@author: Song, Zewei
@contact: songzewei@genomics.cn
"""

import argparse
import sys
import os
import json
import shutil
from zetaSeq import io as seqIO

def print_help():
    print('')
    print('DereCo: dereplicate a group of contigs')
    print('--------------------')
    print('Choose an option:')
    print('create     CREATE a working folder from a fromile or files in a directory.')
    print('calculate  CALCULATE similarity and remove redundant sequences.')
    print('update     UPDATE a working directory with new files in the target path.')
    print('--------------------')
    print('Song, Zewei')
    print('songzewei@genomics.cn')
    print('')

def create(args_input, args_output, args_cutoff, args_minlen):
    print('Dereco: dereplicate a group of contigs')
    folder = False
    if os.path.isfile(args_input):
        print('Origin file: {0}'.format(args_input))
        if args_input.endswith('.fa') or args_input.endswith('.fa.gz'):
            if args_input.endswith('.fa'):
                sn = args_input.split('/')[-1][:-3]
            else:
                sn = args_input.split('/')[-1][:-6]
        else:
            print('[ERROR] The input file has to be .fa or .fa.gz')
            sys.exit()
        print('File header: {0}'.format(sn))
        target_file = args_input
    elif os.path.isdir(args_input):
        folder = True
        if not args_input.endswith('/'): args_input += '/'
        print('Origin directory: {0}'.format(args_input))
        # Search in the target folder for all .fa.gz files, .fa will be ignored
        count_fa = 0
        fagz = []
        for item in os.listdir(args_input):
            if item.endswith('.fa.gz'):
                fagz.append(args_input + item)
            elif item.endswith('.fa'):
                count_fa += 1
        if count_fa > 0:
            print('Found {0} .fa files in {1}, but will not add them to the working directory'.format(count_fa, args_input))

    # Check if the output folder exist
    if not args_output.endswith('/'): args_output += '/'
    if os.path.isdir(args_output):
        print('[ERROR] The output folder {0} already exist, please check it.'.format(args_output))
        sys.exit()
    else:
        os.mkdir(args_output)
        print('Working folder generated at: {0}'.format(args_output))

    # Write an option file
    options = {'cutoff': args_cutoff, 'minlen': args_minlen,'input': args_input, 'output': args_output, 'folder': folder, 'finished': False}
    if folder:
        options['added'] = fagz

    # Rename the sequence names to avoid duplicated label
    if folder: # Target is a folder, will concat all its .fa.gz files first
        cmd = ['cat']
        cmd += [' '.join(fagz)]
        cmd += ['> ' + args_output + 'tmp_cat.fa.gz']
        target_file = args_output + 'tmp_cat.fa.gz'
        cmd = ' '.join(cmd)
        print('[SHELL] ' + cmd)
        os.system(cmd)
    cmd = ['seqtk seq -L ' + str(args_minlen)]
    cmd += ['-C']
    cmd += [target_file]
    cmd += ['|']
    cmd += ['seqtk rename -']
    cmd += ['contigs_']
    cmd += ['>']
    cmd += [args_output + sn + '.renamed.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)
    os.system('rm ' + args_output + 'tmp_cat.fa.gz')

    # Write large and small sequences to the working folder
    print('Length cutoff: {0}'.format(args_cutoff))
    file_large = args_output + sn + '.large.fa'
    file_small = args_output + sn + '.small.fa'
    options['large_file': file_large]
    options['small_file': file_small]

    cmd = ['vsearch --fastx_filter']
    cmd += [args_output + sn + '.renamed.fa']
    cmd += ['--fastq_minlen ' + str(args_cutoff)]
    cmd += ['--fastaout ' + file_large]
    cmd += ['--fastaout_discarded ' + file_small]
    cmd += ['--fasta_width 0']
    cmd += ['--quiet']
    cmd = ' '.join(cmd)
    print('[VSEARCH] ' + cmd)
    os.system(cmd)
    os.remove(args_output + sn + '.renamed.fa')
   
    if os.stat(file_large).st_size == 0: # Check fi large file is empty
        print('[DereCo] The large file is empty, you may want to lower the cutoff.')
        shutil.rmtree(args_output)
        print('[DereCo] {0} removed'.format(args_output))
        print('[DereCo] EXIT')
        sys.exit() 
    
    # Save the options.json file
    with open(args_output + 'options.json', 'w') as f:
        json.dump(options, f)
        
    print('[DereCo] Generated the LARGE file: {0}.gz'.format(file_large))
    print('[DereCo] Generated the SMALL file: {0}.gz'.format(file_small))
    print('[DereCo] to dereplicate, run: dereco calc -i {0} -t [threads]'.format(args_output))

    return None

# retuen a list of query names to be removed from alignments
def derep_paf(input_paf):
    removal = []
    with open(input_paf, 'r') as f:
        for line in f:
            line = line.strip('\n').split('\t')
            if line[0] != line[5] and int(line[1]) < int(line[6]): # alignment is short --> long
                ident = float(int(line[10]) / int(line[9])) # This is the identity (similarity) of the alignment
                match = float(int(line[10]) / (int(line[1]) - 0)) # This is the percent of length matched on query
                if ident > 0.99 and match > 0.97:
                    removal.append(line[0])
        removal = set(removal)
    return removal

# reture a seq list by removing sequencs in the removal_list
def remove_seqs(input_seqs, removal_list):
    result = []
    for item in seqIO.sequence(input_seqs):
        if item[0] not in removal_list:
            result.append(item)
    return result

def get_size_count(input_seqs):
    size = 0
    count = 0
    for item in seqIO.sequence(input_seqs):
        count += 1
        size += len(item[1])
    return size, count

def calculate(args_input, args_threads):
    if not args_input.endswith('/'): args_input += '/'
    if not os.path.isfile(args_input + 'options.json'):
        print('[ERROR] Did not find options.json, use dereco create to set up the working directory.')
        sys.exit()
    else:
        with open(args_input + 'options.json', 'r') as f:
            options = json.load(f)
            file_large = options['large_file']
            file_small = options['small_file']
            if options['finished']:
                print('[ERROR] Directory {0} is marked as FINISHED.'.format(args_input))
                sys.exit()
    print('Large file: {0}'.format(file_large))
    print('Small file: {0}'.format(file_small))
    print('Cutoff: {0}'.format(options['cutoff']))

    sum_large, count_large = get_size_count(file_large)
    sum_small, count_small = get_size_count(file_small)

    # minimap2 asm5 large large
    cmd = ['minimap2']
    cmd += ['-x asm5']
    cmd += ['-t ' + str(args_threads)]
    cmd += [file_large]
    cmd += [file_large]
    cmd += ['-o ' + args_input + 'align_large_vs_large.paf']
    cmd += ['2> /dev/null']
    cmd = ' '.join(cmd)
    print('[MINIMAP2] ' + cmd)
    os.system(cmd)

    # dereplicate large vs large
    removal = derep_paf(args_input + 'align_large_vs_large.paf')
    keep = [i[0] for i in seqIO.sequence(file_large) if i[0] not in removal]
    print('[DereCo] Removing {0} sequences ...'.format(len(removal)))
    with open(args_input + 'kplist', 'w') as f:
        f.write('{0}\n'.format('\n'.join(keep)))
    cmd = ['seqtk subseq']
    cmd += [file_large]
    cmd += [args_input + 'kplist']
    cmd += ['> ' + args_input + 'dereco_large_vs_large.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)
    sum1, c1 = get_size_count(args_input + 'dereco_large_vs_large.fa')
    print('[DereCo] Dereplicated large file: {0:,} -> {1:,} (bps) / {2:,} -> {3:,} (count)'.format(sum_large, sum1, count_large, c1))

    # minimap2 asm5 large small
    cmd = ['minimap2']
    cmd += ['-x asm5']
    cmd += ['-t ' + str(args_threads)]
    cmd += [args_input + 'dereco_large_vs_large.fa']
    cmd += [file_small]
    cmd += ['-o ' + args_input + 'align_small_vs_large.paf']
    cmd += ['2> /dev/null']
    cmd = ' '.join(cmd)
    print('[MINIMAP2] ' + cmd)
    os.system(cmd)

    # dereplicate small vs large
    removal = derep_paf(args_input + 'align_small_vs_large.paf')
    keep = [i[0] for i in seqIO.sequence(file_small) if i[0] not in removal]
    print('[DereCo] Removing {0} sequences ...'.format(len(removal)))
    with open(args_input + 'kplist', 'w') as f:
        f.write('{0}\n'.format('\n'.join(keep)))
    cmd = ['seqtk subseq']
    cmd += [file_small]
    cmd += [args_input + 'kplist']
    cmd += ['> ' + args_input + 'dereco_small_vs_large.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)
    sum2,c2 = get_size_count(args_input + 'dereco_small_vs_large.fa')
    print('[DereCo] Dereplicated small file: {0:,} -> {1:,} (bps) / {2:,} -> {3:,} (count)'.format(sum_small, sum2, count_small, c2))

    # minimap2 asm5 small vs small
    cmd = ['minimap2']
    cmd += ['-x asm5']
    cmd += ['-t ' + str(args_threads)]
    cmd += [args_input + 'dereco_small_vs_large.fa']
    cmd += [args_input + 'dereco_small_vs_large.fa']
    cmd += ['-o ' + args_input + 'align_small_vs_small.paf']
    cmd += ['2> /dev/null']
    cmd = ' '.join(cmd)
    print('[MINIMAP2] ' + cmd)
    os.system(cmd)

    # dereplicate small vs small
    removal = derep_paf(args_input + 'align_small_vs_small.paf')
    keep = [i[0] for i in seqIO.sequence(args_input + 'dereco_small_vs_large.fa') if i[0] not in removal]
    print('[DereCo] Removing {0} sequences ...'.format(len(removal)))
    with open(args_input + 'kplist', 'w') as f:
        f.write('{0}\n'.format('\n'.join(keep)))
    cmd = ['seqtk subseq']
    cmd += [args_input + 'dereco_small_vs_large.fa']
    cmd += [args_input + 'kplist']
    cmd += ['> ' + args_input + 'dereco_small_vs_small.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)
    sum3,c3 = get_size_count(args_input + 'dereco_small_vs_small.fa')
    print('[DereCo] Dereplicated small file: {0:,} -> {1:,} -> {2:,} (bps) / {3:,} -> {4:,} -> {5:,} (count)'.format(sum_small, sum2, sum3, count_small, c2, c3))

    # concat all
    cmd = ['cat']
    cmd += [args_input + 'dereco_large_vs_large.fa']
    cmd += [args_input + 'dereco_small_vs_small.fa']
    cmd += ['> ' + args_input + 'derecp_final.fa']
    cmd = ' '.join(cmd)
    print('[CAT] ' + cmd)
    os.system(cmd)

    if os.path.isfile(args_input + 'derecp_final.fa'):
        os.system('touch ' + args_input + 'FINISHED')
    
    print('\n\t---Report---')
    print('Origin large: {0:,} (bps) / {1:,} (count)'.format(sum_large, count_large))
    print('Origin small: {0:,} (bps) / {1:,} (count)'.format(sum_small, count_small))
    print('Origin all: {0:,} (bps) / {1:,} (count)'.format(sum_large + sum_small, count_large + count_small))
    print('Derep large: {0:,} (bps) / {1:,} (count)'.format(sum1, c1))
    print('Derep small: {0:,} (bps) / {1:,} (count)'.format(sum3, c3))
    print('Derep all: {0:,} (bps) / {1:,} (count)'.format(sum1 + sum3, c1 + c3))
    print('Compression rate: {0:.2f}'.format((sum_large + sum_small) / (sum1 + sum3)))
    print('Origin size / Derep size: {0:,} / {1:,}'.format(sum_large + sum_small, sum1 + sum3))

def stat(args_input, args_output):
    pass

if len(sys.argv[:]) == 1:
    option = ''
else:
    option = sys.argv[1]
if option == 'create':
    print('CREATE a working folder from a file or files in a directory.')
    parser = argparse.ArgumentParser(prog='dereco create')
    parser.add_argument('-i', '--input', help='Path to the original contigs group file.')
    parser.add_argument('-o', '--output', help='Path to the output folder.')
    parser.add_argument('-c', '--cutoff', type=int, default=1000000, help='Length cutff to divide the input.')
    parser.add_argument('-m', '--minlen', type=int, default=2000, help='Minimum length to keep a sequence.')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        create(args.input, args.output, args.cutoff, args.minlen)
elif option in ('calculate', 'calc'):
    print('Calculate similarity and dereplicate')
    parser = argparse.ArgumentParser(prog='dereco calculate')
    parser.add_argument('-i', '--input', help='Path to the prep output folder.')
    parser.add_argument('-t', '--threads', type=int, help='Numer of threads')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        calculate(args.input, args.threads)
elif option == 'update':
    print('Generate a report')
    parser = argparse.ArgumentParser(prog='dereco stat')
    parser.add_argument('-i', '--input', help='Path to the stat output folder.')
    parser.add_argument('-o', '--output', help='Path to the report file')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        stat(args.input, args.output)
else:
    print_help()
