#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Created on Thu May 19 17:33:42 2022

Dereplicate a group of contigs

dereco prep -i /path/to/contigs.fa.gz -o /path/to/out/folder/ -c 1000000
dereco cacl -i /path/to/out/folder -t 4

He who loves to comment his code is unlikely to have bad luck.
@author: Song, Zewei
@contact: songzewei@genomics.cn
"""

import argparse
import sys
import os
import json
import shutil
import time
from zetaSeq import io as seqIO
import hashlib
import random
import string


def print_help():
    print('')
    print('DereCo: dereplicate a group of contigs')
    print('--------------------')
    print('Choose an option:')
    print('create     CREATE a working folder from a fromile or files in a directory.')
    print('devour     DEVOUR short sequences into longer ones passing a similarity threshold.')
    print('update     UPDATE a working directory with new files in the target path.')
    print('status     Print out the STATUS of a working directory.')
    print('--------------------')
    print('Song, Zewei')
    print('songzewei@genomics.cn')
    print('')


def check_dependency(tools):
    checker =[False] * len(tools)
    for index, item in enumerate(tools):
        if shutil.which(item) is None:
            print('[ERROR] {0} is not found in your ENV'.format(item))
            checker[index] = True
        else:
            print('[DereCo] {0} is ready'.format(item))
    if sum(checker) > 0:
        print('[DereCo] EXIT')
        sys.exit()


def get_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str


def create(args_input, args_output, args_cutoff, args_minlen, args_sourmash):
    time_span = [0, 0]
    time_span[0] = time.time()
    print('Dereco: dereplicate a group of contigs')
    if args_sourmash: check_dependency(['seqtk', 'vsearch', 'sourmash'])
    else: check_dependency(['seqtk', 'vsearch'])
    folder = False
    fagz = []
    sn = ''
    if os.path.isfile(args_input):  # Input is a file
        print('Origin file: {0}'.format(args_input))
        if args_input.endswith('.fa') or args_input.endswith('.fa.gz'):
            pass
        else:
            print('[ERROR] The input file has to be .fa or .fa.gz')
            sys.exit()
        target_file = args_input
    elif os.path.isdir(args_input):  # Input is a folder
        folder = True
        if not args_input.endswith('/'): args_input += '/'
        print('Origin directory: {0}'.format(args_input))
        # Search in the target folder for all .fa.gz files, .fa will be ignored
        count_fa = 0
        for item in os.listdir(args_input):
            if item.endswith('.fa.gz'):
                fagz.append(args_input + item)
            elif item.endswith('.fa'):
                count_fa += 1
        if count_fa > 0:
            print('Found {0} .fa files in {1}, but will not add them to the working directory'.format(count_fa,
                                                                                                      args_input))
        if len(fagz) == 0:
            print('Found 0 .fa.gz files')
            print('[DereCo] EXIT')
            sys.exit()

    # Check if the output folder exist
    if not args_output.endswith('/'): args_output += '/'
    if os.path.isdir(args_output):
        print('[ERROR] The output folder {0} already exist, please check it.'.format(args_output))
        sys.exit()
    else:
        os.mkdir(args_output)
        print('Working folder generated at: {0}'.format(args_output))

    # Write an option file
    options = {'cutoff': args_cutoff, 'minlen': args_minlen,
               'target': args_input, 'wd': args_output,
               'folder': folder, 'final': '', 'finished': False,
               'threads': 1, 'cigar': False,
               'origin_size': 0, 'derep_size': 0,
               'sig': args_sourmash,
               'big_head_son':'', 'small_head_dad':''}
    if folder:
        with open(args_output + '.contigs', 'w') as f:
            for item in fagz:
               f.write('{0}\n'.format(item))
    else:
        with open(args_output + '.contigs', 'w') as f:
            f.write('{0}\n'.format(args_input))
    # Rename the sequence names to avoid duplicated label
    if folder:  # Target is a folder, will concat all its .fa.gz files first
        cmd = ['cat']
        cmd += [' '.join(fagz)]
        cmd += ['> ' + args_output + '_tmp.cat.fa.gz']
        target_file = args_output + '_tmp.cat.fa.gz'
        cmd = ' '.join(cmd)
        if len(fagz) >= 10:
            print('[DereCo] Concatenate {0} files ...'.format(len(fagz)))
            print('[SHELL ] cat ' + ' '.join(fagz[:8]) + ' ... ' + fagz[10] + ' > ' + args_output + '_tmp.cat.fa.gz') 
        else:
            print('[SHELL] ' + cmd)
        os.system(cmd)
    else:
        target_file = args_input
    cmd = ['seqtk seq -L ' + str(args_minlen)]
    cmd += ['-C'] # -C is requied to remove all comments
    cmd += [target_file]
    cmd += ['|']
    cmd += ['seqtk rename -']
    cmd += ['contigs_']
    cmd += ['>']
    cmd += [args_output + '_tmp.cat.renamed.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)
    if folder:
        os.system('rm ' + args_output + '_tmp.cat.fa.gz')  # remove the temp cat file

    # sourmash signature
    if options['sig']:
        print('[DereCo] Calculating sourmash sigature: k=21,k=31,k=51,scaled=1000,abund to {0}'.format(args_output + 'minhash_origin.sig'))
        cmd = ['sourmash sketch dna']
        cmd += ['-p k=21,k=31,k=51,scaled=100000,abund']
        cmd += [args_output + '_tmp.cat.renamed.fa']
        cmd += ['-o ' + args_output + 'minhash_origin.sig']
        cmd += ['2> /dev/null']
        cmd = ' '.join(cmd)
        print('[SOURMASH] ' + cmd)
        os.system(cmd)

    # Write large and small sequences to the working folder
    print('Length cutoff: {0}'.format(args_cutoff))
    file_large = args_output + 'contigs.large.fa'
    file_small = args_output + 'contigs.small.fa'
    options['big_head_son'] = file_large
    options['small_head_dad'] = file_small

    cmd = ['vsearch --fastx_filter']
    cmd += [args_output + '_tmp.cat.renamed.fa']
    cmd += ['--fastq_minlen ' + str(args_cutoff)]
    cmd += ['--fastaout ' + file_large]
    cmd += ['--fastaout_discarded ' + file_small]
    cmd += ['--fasta_width 0']
    cmd += ['--quiet']
    cmd = ' '.join(cmd)
    print('[VSEARCH] ' + cmd)
    os.system(cmd)
    os.remove(args_output + '_tmp.cat.renamed.fa')

    if os.stat(file_large).st_size == 0:  # Check if the large file is empty
        print('[DereCo] The large file is empty, you may want to lower the cutoff.')
        shutil.rmtree(args_output)
        print('[DereCo] {0} removed'.format(args_output))
        print('[DereCo] EXIT')
        sys.exit()
    else:
        with open(args_output + 'FLOW', 'w') as f:
            f.write('{0}\t{1}\n'.format(file_large, file_large))
            f.write('{0}\t{1}\n'.format(file_small, file_large))
            f.write('{0}\t{1}\n'.format(file_small, file_small))

        # Save the options.json file
    with open(args_output + 'options.json', 'w') as f:
        json.dump(options, f)

    print('[DereCo] Generated the LARGE file: {0}'.format(file_large))
    print('[DereCo] Generated the SMALL file: {0}'.format(file_small))
    print('[DereCo] Generated options.jaon')
    print('[DereCo] Generated FLOW')
    print('[DereCo] Next run: dereco calculate -i {0} -t [threads]'.format(args_output))
    time_span[1] = time.time()
    print('[DereCo] Used {0:,.0f} seconds'.format(time_span[1] - time_span[0]))

    return None


# retuen a list of query names to be removed from alignments
def derep_paf(input_paf, offset):
    removal = []
    with open(input_paf, 'r') as f:
        for line in f:
            line = line.strip('\n').split('\t')
            if line[0] != line[5] and int(line[1]) < int(line[6]):  # alignment is short --> long
                ident = float(int(line[10]) / int(line[9]))  # This is the identity (similarity) of the alignment
                match = float(int(line[10]) / (int(line[1]) - offset))  # This is the percent of length matched on query
                if ident >= 0.99 and match >= 0.97:
                    removal.append((line[0], int(line[1])))
        removal = set(removal)
    return removal

# Dereplicate a query file against the ref file
def dereplicate(query, ref, threads, offset, cigar):
    # minimap2 asm5 ref query
    hash_object = hashlib.md5((query+ref+get_random_string(10)).encode())
    tmp_header = '__tmp__' + hash_object.hexdigest()
    cmd = ['minimap2']
    cmd += ['-x asm5']
    cmd += ['-t ' + str(threads)]
    if cigar: cmd += ['-c']
    cmd += [ref]
    cmd += [query]
    cmd += ['-o ' + tmp_header + '.paf']
    cmd += ['2> /dev/null']
    cmd = ' '.join(cmd)
    print('[MINIMAP2] ' + cmd)
    os.system(cmd)

    # dereplicate query against ref
    removal = derep_paf(tmp_header + '.paf', offset)
    if len(removal) > 0:
        rm_names = set([x[0] for x in removal])
        rm_bps = sum([x[1] for x in removal])
        rm_max = max([x[1] for x in removal])
        rm_min = min([x[1] for x in removal])
        rm_ave = rm_bps / len(rm_names)
    else:
        rm_names = []
        rm_bps, rm_max, rm_min, rm_ave = 0, 0, 0, 0
    keep = [i[0] for i in seqIO.sequence(query) if i[0] not in rm_names]
    print('[DereCo] Removing {0:,} sequences: {1:,} bps, {2:,.0f} / seq, MAX = {3:,}, MIN = {4:,}'.format(len(removal), rm_bps, rm_ave, rm_max, rm_min))
    with open(tmp_header + '_kplist', 'w') as f:
        f.write('{0}\n'.format('\n'.join(keep)))
    cmd = ['seqtk subseq']
    cmd += [query]
    cmd += [tmp_header + '_kplist']
    cmd += ['> ' + tmp_header + '_query.fa']
    cmd = ' '.join(cmd)
    print('[SEQTK] ' + cmd)
    os.system(cmd)

    # replace old query with new query
    os.remove(query)
    shutil.move(tmp_header + '_query.fa', query)
    os.remove(tmp_header + '_kplist')
    os.remove(tmp_header + '.paf')
    print('[DereCo] {0} is dereplicated'.format(query))

    return None

def get_size_count(input_seqs):
    size = 0
    count = 0
    for item in seqIO.sequence(input_seqs):
        count += 1
        size += len(item[1])
    return size, count


def devour(args_input, args_threads, args_offset, args_cigar):
    hash_object = hashlib.md5((args_input+get_random_string(10)).encode())
    tmp_header = '__tmp__' + hash_object.hexdigest()
    time_span = [0, 0]
    time_span[0] = time.time()
    if not args_input.endswith('/'): args_input += '/'
    if not os.path.isfile(args_input + 'options.json'):
        print('[ERROR] Did not find options.json, use "dereco create" to set up the working directory.')
        sys.exit()
    elif not os.path.isfile(args_input + 'FLOW'):
        print('[ERROR] Did not find FLOW, use "dereco create" to set up the working directory.')
    else:
        with open(args_input + 'options.json', 'r') as f:
            options = json.load(f)
            options['offset'] = args_offset
            if options['finished']:
                print('[DeroCo] This directory is marked as FINISHED')
                sys.exit()
            else:
                flow = []
                with open(args_input + 'FLOW', 'r') as f:
                    for line in f:
                        line = line.strip('\n').split('\t')
                        flow.append(tuple(line))
    if options['sig']: check_dependency(['seqtk', 'minimap2', 'sourmash'])
    else: check_dependency(['seqtk', 'minimap2'])
    
    print('[DereCo] Cutoff: {0}'.format(options['cutoff']))
    print('[DereCo] Minimum length: {0}'.format(options['minlen']))
    print('[DereCo] Query length offset: {0}'.format(options['offset']))
    options['cigar'] = args_cigar
    if options['cigar']: print('[DereCo] Cigar enabled in minimap2')
    else: print('[DereCo] Cigar disabled in minimap2')   

    # Get the original file size and count
    sum0 = [0,0]
    c0 = [0, 0]
    sum0[0], c0[0] = get_size_count(options['big_head_son'])
    try:
        sum0[1], c0[1] = get_size_count(options['small_head_dad'])
    except IndexError:
        sum0[1], c0[1] = 0, 0
    
    print('[DereCo] FLOW started:')
    for item in flow:
        query = item[0]
        ref = item[1]
        if not os.path.isfile(query):
            print('[ERROR] {0} is missing'.format(query))
            print('[DereCo] EXIT')
            sys.exit()
        elif not os.path.isfile(ref):
            print('[ERROR] {0} is missing'.format(ref))
            print('[DereCo] EXIT')
            sys.exit()
        print('[DereCo] FLOW: {0} -> {1}'.format(query, ref))
        sum_query, count_query = get_size_count(query)
        dereplicate(query, ref, args_threads, args_offset, args_cigar)
        sum1, c1 = get_size_count(query)
        print('[DereCo] Dereplicated {4}: {0:,} -> {1:,} (bps) / {2:,} -> {3:,} (count)'.format(sum_query, sum1, count_query, c1, query))

    # concat all and rename with prefix nrc_ aka Non-redundant contigs
    cmd = ['cat']
    cmd += [options['big_head_son']]
    cmd += [options['small_head_dad']]
    cmd += ['| seqtk rename - nrc_ > ' + args_input + 'dereco_final.fa']
    cmd = ' '.join(cmd)
    print('[SHELL] ' + cmd)
    os.system(cmd)

    options['final'] = args_input + 'dereco_final.fa'
    options['finished'] = True

    if options['sig']:
        cmd = ['sourmash sketch dna']
        cmd += ['-p k=21,k=31,k=51,scaled=100000,abund']
        cmd += [options['final']]
        cmd += ['-o ' + args_input + 'minhash_derep.sig']
        cmd += ['2> /dev/null']
        cmd = ' '.join(cmd)
        print('[DereCo] Calculating minhash sigature for the dereplicated file')
        print('[SOURMASH] ' + cmd)
        os.system(cmd)

    if os.path.isfile(args_input + 'dereco_final.fa'):
        os.system('touch ' + args_input + 'FINISHED')
        os.remove(options['big_head_son'])
        os.remove(options['small_head_dad'])
    
    sum1, c1 = get_size_count(args_input + 'dereco_final.fa')
    count = 0
    with open(args_input + '.contigs', 'r') as f:
        for line in f:
            count += 1
    print('\n\t---Report---')
    print('Number of contigs: {0}'.format(count))
    print('Compression rate: {0:.2f}'.format(sum(sum0) / (sum1)))
    print('Origin size / Derep size: {0:,} / {1:,} --> {2:,} bps'.format(sum(sum0), sum1, sum(sum0) - sum1))
    print('Origin count / Derep count: {0:,} / {1:,} --> {2:,} seqs'.format(sum(c0), c1, sum(c0) - c1))
    options['origin_size'] = sum(sum0)
    options['derep_size'] = sum1
    options['origin_count'] = sum(c0)
    options['derep_count'] = c1
    options['cigar'] = args_cigar
    if options['folder']:
        print('To update: dereco update -i {0} -t [threads]'.format(options['wd']))
    with open(args_input + 'options.json', 'w') as f:
        json.dump(options, f)
    time_span[1] = time.time()
    print('[DereCo] Used: {0:,.0f} seconds'.format(time_span[1] - time_span[0]))

    return None

def update(args_input):
    time_span = [0, 0]
    time_span[0] = time.time()
    # Check options.json
    if os.path.isfile(args_input + 'options.json'):
        with open(args_input + 'options.json', 'r') as f:
            options = json.load(f)
    count = 0
    contigs_finished = []
    with open(args_input + '.contigs', 'r') as f:
        for line in f:
            contigs_finished.append(line.strip('\n'))
            count += 1
    contigs_add = []
    if not options['folder']:  # Target is not a folder
        print('[ERROR] Target is a file not a directory.')
        print('[DereCo] EXIT')
    elif not options['finished']:  # Input directory is NOT finished
        print('[ERROR] Input directory is not finished.')
        print('[DereCo] run: dereco calculate -i {0} -t [threads]'.format(options['wd']))
    else:
        print('[DereCo] {0} is a FINISHED working directory'.format(options['wd']))
        print('[DereCo] Update contigs (.fa.gz) in {0}'.format(options['target']))
        print('[DereCo] Finished contigs: {0}'.format(count))
        contigs_finished = set([i.split('/')[-1] for i in contigs_finished])
        for item in os.listdir(options['target']):
            if item.endswith('.fa.gz'):
                if item not in contigs_finished:
                    contigs_add.append(options['target'] + item)
                    print('[DereCo] Add new contig: {0}'.format(item))
        if len(contigs_add) > 0:
            count_added = 0
            print('[DereCo] Added {0} new contig(s)'.format(len(contigs_add)))
            with open(args_input + '.contigs', 'a') as f:
                for item in contigs_add:
                    f.write('{0}\n'.format(item))
                    count_added += 1
        else:
            print('[DereCo] No new contigs found in {0}'.format(options['target']))
            print('[DereCo] EXIT')
            sys.exit()

    # concat new contigs as new small file
    options['small_head_dad'] = options['wd'] + 'contigs.small.fa'
    cmd = ['cat']
    cmd += [' '.join(contigs_add)]
    cmd += ['| seqtk seq -L ' + str(options['minlen']) + ' -C | seqtk rename - added_ > ' + options['small_head_dad']] # need to use seqtk seq -C to remove comments in labels
    cmd = ' '.join(cmd)
    print('[SHELL] ' + cmd)
    os.system(cmd)

    # Set large_file = final
    options['big_head_son'] = options['wd'] + 'contigs.large.fa'
    cmd = ['mv']
    cmd += [options['final']]
    cmd += [options['big_head_son']]
    cmd = ' '.join(cmd)
    print('[SHELL] ' + cmd)
    shutil.move(options['final'], options['big_head_son'])
    options['final'] = ''
   
    # Write a new FLOW to update
    with open(args_input + 'FLOW', 'w') as f:
        f.write('{0}\t{1}\n'.format(options['small_head_dad'], options['small_head_dad']))
        f.write('{0}\t{1}\n'.format(options['small_head_dad'], options['big_head_son']))
        f.write('{0}\t{1}\n'.format(options['big_head_son'], options['small_head_dad']))

    # Turn off finished flag
    options['finished'] = False
    with open(args_input + 'options.json', 'w') as f:
        json.dump(options, f)
    if os.path.isfile(options['wd'] + 'FINISHED'):
        os.remove(options['wd'] + 'FINISHED')

    # Print calculate command
    print('[DereCo] Working directory set up ready')
    print('[DereCo] WD = {0}'.format(options['wd']))
    print('[DereCo] Devoured contigs: {0}'.format(count))
    print('[DereCo] Added contigs: {0}'.format(count_added))
    print('[DereCo] Large file = {0}'.format(options['big_head_son']))
    print('[DereCo] Small file = {0}'.format(options['small_head_dad']))
    print('[DereCo] New FLOW is ready')
    print('[DereCo] NEXT run: dereco calculate -i {0} -t [threads]'.format(options['wd']))
    time_span[1] = time.time()
    print('[DereCo] Used: {0:,.0f}'.format(time_span[1] - time_span[0]))

    return None

def status(args_input):
    print('[DereCo] Checking {0}'.format(args_input))
    if not args_input.endswith('/'): args_input += '/'
    if not os.path.isdir(args_input):
        print('[ERROR] {0} not exist')
        print('[DereCo] EXIT')
        sys.exit()
    else:
        if not os.path.isfile(args_input + 'options.json'):
            print('[ERROR] options.json not exist, {0} is not a working directory'.format(args_input))
            print('[DereCo] EXIT')
            sys.exit()
        else:
            with open(args_input + 'options.json', 'r') as f:
                options = json.load(f)
            print('[DereCo] Loading options.json')
        if not os.path.isfile(args_input + '.contigs'):
            print('[ERROR] .contigs not exist, {0} is not a working directory'.format(args_input))
            print('[DereCo] EXIT')
            sys.exit()
        else:
            count = 0
            with open(args_input + '.contigs', 'r') as f:
                for line in f:
                    count +=1

    if options['finished']:
        print('[DereCo] Project is FINISHED')
        print('[DereCo] Project path: {0}'.format(options['wd']))
        print('[DereCo] Non-redundant contigs set in {0}'.format(options['final']))
        print('[DereCo] Compressed from {0} files'.format(count))
        print('[DereCo] Cutoff = {0:,}'.format(options['cutoff']))
        print('[DereCo] Minimum length = {0:,}'.format(options['minlen']))
        print('[DereCo] Query length offset: {0}'.format(options['offset']))
        if options['cigar']: print('[DereCo] Cigar enabled in minimap2')
        else: print('[DereCo] Ciagr disabled in minimap2')
        print('[DereCo] Origin versus derep: {0:,} / {1:,} (bps)'.format(options['origin_size'], options['derep_size']))
        print('[DereCo] Compression rate: {0:.2f}'.format(options['origin_size'] / options['derep_size']))        
        print('[DereCo] Path to update: {0}'.format(options['target']))
    else:
        print('[DereCo] Project is NOT finished')
        print('[DereCo] Project path: {0}'.format(options['wd']))
        print('[DereCo] Cutoff = {0:,}'.format(options['cutoff']))
        print('[DereCo] Minimum length = {0:,}'.format(options['minlen']))
        print('[DereCo] Source of contigs: {0}'.format(options['target']))
        print('[DereCo] Added {0} files'.format(count))
    with open(args_input + 'FLOW', 'r') as f:
        print('[DereCo] FLOW')
        for line in f:
            line = line.strip('\n').split('\t')
            print('[DereCo] FLOW: {0} -> {1}'.format(line[0], line[1]))
    if options['finished'] and options['sig']:
        cmd = ['sourmash compare']
        cmd += ['-k 21']
        cmd += [args_input + 'minhash_origin.sig']
        cmd += [args_input + 'minhash_derep.sig']
        cmd = ' '.join(cmd)
        print('[SOURMASH] ' + cmd)
        os.system(cmd)


def graph(ava_paf):
    link = []
    with open(ava_paf, 'r') as f:
        for line in f:
            line = line.strip('\n').split('\t')
            query = {'name': line[0], 'len':int(line[1]), 'start':int(line[2]), 'end':int(line[3]), 'strand':line[4]}
            target = {'name':line[5], 'len':int(line[6]), 'start':int(line[7]), 'end':int(line[8])}
            match = {'match': int(line[9]), 'align': int(line[10])}
            if query['strand'] == '+':
                qtail = query['len'] - query['end']
                ttail = target['start']
            else:
                qtail = query['len'] - query['end']
                ttail = target['len'] - target['end']
            pident = match['match'] / match['align']
            if qtail <= 600 and ttail <= 600 and pident >= 0.99:
                link.append((query['name'], target['name'], queryy['strand']))

    return link

def layout():
    time_span = [0, 0]
    time_span[0] = time.time()
    # minimap2 ava-ont -c
    time_span[1] = time.time()
    print('[DereCo] Used: {0:,0f} seconds'.format(time_span[1] - time_span[0]))
    
    return None


if len(sys.argv[:]) == 1:
    option = ''
else:
    option = sys.argv[1]
if option == 'create':
    print('CREATE a working folder from a file or files in a directory')
    parser = argparse.ArgumentParser(prog='dereco create')
    parser.add_argument('-i', '--input', help='Path to the original contigs group file.')
    parser.add_argument('-o', '--output', help='Path to the output folder.')
    parser.add_argument('-c', '--cutoff', type=int, default=1000000, help='Length cutff to divide the input.')
    parser.add_argument('-m', '--minlen', type=int, default=2000, help='Minimum length to keep a sequence.')
    parser.add_argument('-s', '--sourmash', action='store_true', help='Indicator to calculate minHash siganture using sourmash.')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        create(args.input, args.output, args.cutoff, args.minlen, args.sourmash)
elif option in ('devour', 'devo'):
    print('DEVOUR short sequences into longer ones passing a similarity threshold')
    parser = argparse.ArgumentParser(prog='dereco calculate')
    parser.add_argument('-i', '--input', help='Path to the prep output folder.')
    parser.add_argument('-f', '--offset', default=0, type=int, help='Offset for the match length')
    parser.add_argument('-c', '--cigar', action='store_true', help='Use more accurate mode of minimap2, but slower.')
    parser.add_argument('-t', '--threads', type=int, default=2, help='Number of threads')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        devour(args.input, args.threads, args.offset, args.cigar)
elif option == 'update':
    print('UPDATE a working directory for new contigs in the target path')
    parser = argparse.ArgumentParser(prog='dereco update')
    parser.add_argument('-i', '--input', help='Path to the stat output folder.')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        update(args.input)
elif option in ('status', 'stat'):
    print('STATUS of a working directory')
    parser = argparse.ArgumentParser(prog='dereco status')
    parser.add_argument('-i', '--input', help='Path to the working directory.')
    if len(sys.argv[:]) == 2:
        parser.print_help()
    else:
        args = parser.parse_args(sys.argv[2:])
        status(args.input)
else:
    print_help()
